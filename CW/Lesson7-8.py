
#________________1___________________

# Створимо ітерований об'єкт - список
my_list = [1, 2, 3, 4, 5]

# Отримуємо ітератор для цього списку
my_iterator = iter(my_list)

# Використаємо ітератор для перебору елементів
print(next(my_iterator))  # Виведе: 1
print(next(my_iterator))  # Виведе: 2
print(next(my_iterator))  # Виведе: 3





# Пример: итератор с использованием for
colors = ["красный", "синий", "зеленый"]  # Это наш список (итерабельный объект)

# Итератор позволяет пройти по каждому элементу списка
for color in colors:
    print(color)


"""
Создайте список с числами от 1 до 5.
Используйте функцию iter(), чтобы создать итератор для этого списка.
Используйте next(), чтобы вывести все числа из списка по очереди или цикл for
"""






class ColorIterator:
    def __init__(self, colors):
        self.colors = colors  # Наш список цветов
        self.index = 0  # Индекс, показывающий текущий цвет в списке

    def __iter__(self):
        return self  # Сообщаем Python, что этот объект является итератором

    def __next__(self):
        # Проверяем, есть ли еще цвета, которые можно вернуть
        if self.index < len(self.colors):
            color = self.colors[self.index]  # Получаем текущий цвет
            self.index += 1  # Переходим к следующему цвету
            return color  # Возвращаем текущий цвет
        else:
            # Сообщаем Python, что элементы закончились, и цикл for должен остановиться
            raise StopIteration

# Создаем итератор для нашего списка цветов
color_iter = ColorIterator(["red", "blue", "green"])

# Когда мы пишем 'for color in color_iter', Python использует метод __iter__ и __next__:
# - __iter__ сообщает, что объект можно перебирать.
# - __next__ возвращает следующий цвет каждый раз, когда цикл for запрашивает следующий элемент.
for i in color_iter:
    print(i)  # Выводим каждый цвет

# Как это работает:
# 1. Цикл 'for' обращается к методу __iter__, который возвращает объект для итерации.
# 2. Затем он вызывает __next__ для получения каждого следующего цвета.
# 3. Когда цветов больше нет, __next__ вызывает StopIteration, и цикл for останавливается.


"""
Создайте класс StringIterator, который в конструкторе будет принимать список строк.
В классе добавьте метод __iter__() для возвращения объекта итератора 
и метод __next__() для последовательного получения строк из списка.
Создайте объект этого класса и используйте цикл for, чтобы вывести все строки.
"""







#________________2___________________

# Генератор для створення чисел від 1 до 5
def my_generator():
    for i in range(1, 6):
        yield i  # Повертаємо значення поступово

# Використовуємо генератор
gen = my_generator()

print(next(gen))  # Виведе: 1
print(next(gen))  # Виведе: 2
print(next(gen))  # Виведе: 3




# Пример: генератор, который создает числа по одному
def count_up_to(limit):
    count = 1
    while count <= limit:
        yield count  # Возвращаем число и "запоминаем" место, где остановились
        count += 1

# Используем генератор для вывода чисел от 1 до 3
for i in count_up_to(3):
    print(i)

"""
Напишите функцию с именем my_generator(), 
которая будет использовать yield для генерации чисел от 1 до 6.
Используйте next(), чтобы получить каждое число.
"""


# Пример: генератор в классе
class Counter:
    def __init__(self, start, end):
        self.start = start  # Начальное значение счётчика
        self.end = end  # Конечное значение счётчика

    def generate(self):
        count = self.start  # Начинаем с начального значения
        while count <= self.end:  # Пока счётчик меньше или равен конечному значению
            yield count  # Используем ключевое слово yield для возвращения текущего значения
            count += 1  # Увеличиваем счётчик на 1

# Создаем объект генератора с числами от 1 до 3
counter = Counter(1, 3)

# Используем цикл for для перебора чисел, возвращаемых генератором
for number in counter.generate():
    print(number)  # Выводим каждое число, которое возвращает генератор


"""
Создайте класс NumberGenerator, который в конструкторе принимает число end.
В классе создайте метод generate(), который будет генерировать числа от 1 до end с помощью yield.
"""









#________________3___________________
# замыкание
def outer_function(x):
    def inner_function(y):
        return x + y  # Замикання: inner_function "пам'ятає" x
    return inner_function

# Використаємо замикання
add_five = outer_function(5)  # Функція зберігає x = 5
print(add_five(10))  # Виведе: 15 (5 + 10)





# Пример замыкания: функция, которая запоминает значение
def outer(x):

    def inner(y):
        return x + y  # Функция inner "помнит" x, даже после выхода из outer
    return inner

# Создаем замыкание, где x = 5
add_five = outer(5)

# Используем замыкание
print(add_five(3))  # Выведет 8, потому что x + y = 5 + 3



"""
Напишите функцию create_counter(), которая возвращает другую функцию.
Внутри возвращаемой функции создайте переменную, которая будет хранить счетчик.
Каждый раз при вызове этой функции увеличивайте счетчик и возвращайте его значение.
"""



# Пример: замыкание в классе
class Adder:
    def __init__(self, x):
        self.x = x

    def add(self):
        def inner(y):
            return self.x + y  # "Помнит" значение self.x
        return inner

# Создаем объект Adder
adder = Adder(5)

# Используем замыкание для сложения
add_five = adder.add()
print(add_five(3))  # Выведет 8, потому что x + y = 5 + 3


"""
Создайте класс Counter с методами get_count() и increment().
В методе increment() используйте замыкание для увеличения счетчика.
"""







#________________4___________________

# Декоратор для вывода сообщения до и после вызова функции
def my_decorator(func):
    def wrapper():
        print("Перед вызовом функции")  # Сообщение до вызова
        func()  # Вызов самой функции
        print("После вызова функции")  # Сообщение после вызова
    return wrapper  # Возвращаем обёртку

# Используем декоратор для функции
@my_decorator  # Это значит, что функция 'say_hello' будет обернута декоратором
def say_hello():
    print("Привет!")  # Простое сообщение

say_hello()  # Вызываем функцию



"""
Напишите декоратор count_calls(), который будет увеличивать счетчик каждый раз, 
когда декорируемая функция вызывается.
Примените декоратор к функции, которая выводит какое-либо сообщение.
"""






# Пример декоратора в классе
class Greeter:
    # Метод, который выводит приветствие
    def greet(self, name):
        print(f"Привет, {name}!")  # Приветствуем по имени

    # Декоратор, который добавляет сообщение перед вызовом функции
    def greeting_decorator(self, func):
        def wrapper(name):
            print("Привет, как ты?")  # Сообщение до вызова функции
            func(name)  # Вызов оригинальной функции (greet)
        return wrapper  # Возвращаем обёртку

# Создаем объект класса Greeter
greeter = Greeter()

# Применяем декоратор к методу greet
greeter.greet = greeter.greeting_decorator(greeter.greet)

# Вызовем декорированную функцию greet
greeter.greet("Аня")



"""
Напишите декоратор count_method_calls(), который будет увеличивать счетчик при каждом вызове метода класса.
Примените декоратор к методу calculate() в классе Calculator, который просто возвращает сумму двух чисел.
"""


